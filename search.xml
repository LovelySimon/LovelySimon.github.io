<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统学习历程</title>
      <link href="/2025/01/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
      <url>/2025/01/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>计算机硬件：极简的公理系统（导线，逻辑门，时钟，触发器）就能够支持非常复杂的数字系统设计</p><p>硬件和软件的中间层，需要了解全部但不要细究全部</p><ul><li>对单机作出抽象</li><li>支撑多个程序执行</li></ul><h2 id="从应用角度看操作系统"><a href="#从应用角度看操作系统" class="headerlink" title="从应用角度看操作系统"></a>从应用角度看操作系统</h2><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20250117155511892.png" alt="image-20250117155511892"></p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20250117164939996.png" alt="image-20250117164939996"></p><p>可以对如图所示的文件进行gcc的编译得到想要的exe可执行文件，也可以使用gcc -c来先进行编译得到.o文件在进行链接</p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20250117165106573.png" alt="image-20250117165106573"></p><p><strong>在计算机中，我们所有的指令都是计算和move指令，并没有关闭程序和关闭计算机的指令，那么这个过程是谁在发挥作用？</strong></p><p>答案是操作系统。</p><p>借助操作系统来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $SYS_exit , %rax #exit(</span><br><span class="line">movq $1,         %rdi # status=1</span><br><span class="line">syscall               #);</span><br></pre></td></tr></table></figure><ul><li>将系统调用的参数放到寄存器中</li><li>执行sys call，操作系统接管程序，操作系统可以任意改变程序状态（甚至终止程序）</li></ul><p><strong>应用程序&#x3D;计算+操作系统API</strong></p><p>举例说明：</p><ul><li><p>窗口管理器：能直接管理屏幕设备</p><p>​能够和其他进程通信</p></li><li><p>任务管理器：能访问操作系统提供的进程对象</p></li><li><p>杀毒软件：文件静态扫描（read），主动防御（ptrace）</p></li></ul><p><strong>操作系统的职责：提供令应用程序舒适的抽象（对象+API）</strong></p><h3 id="理解高级语言程序"><a href="#理解高级语言程序" class="headerlink" title="理解高级语言程序"></a>理解高级语言程序</h3><ul><li><p>C语言代码经过编译之后得到二进制文件，执行二进制文件就可以依次执行指令，每次执行一条“语句”</p></li><li><p>在使用gdb调试代码的时候可以发现，c语言文件的执行也是一种状态机，那我们可以试着使用c语言的源代码来模拟状态机的运行，也就是将代码写成<strong>“simpleC”</strong></p></li></ul><p><strong>状态机是拥有严格数学定义的对象，这意味着可以用定义的方式写出来</strong></p><ul><li>状态就是各种栈帧和全局变量的组合。</li><li>初始状态下仅有一个栈帧（main函数栈帧），且全局变量均为初始值（PC&#x3D;0）</li><li>状态迁移：执行栈帧PC</li></ul><p>试图把c代码改写成simpleC：</p><ul><li>每一条语句至多一次运算</li><li>条件语句中不包含运算</li></ul><h3 id="编译器与编译优化"><a href="#编译器与编译优化" class="headerlink" title="编译器与编译优化"></a>编译器与编译优化</h3><ul><li>编译器的输入：高级c语言代码</li><li>编译器的输出：汇编代码（指令序列）</li><li>编译器就是状态机之间的翻译器</li></ul><p><strong>simpleC翻译</strong>：</p><ul><li>运算：把操作数load到寄存器，执行运算，store写回结果</li><li>分支&#x2F;循环：使用条件跳转分别执行代码</li><li>函数调用：专门留一个寄存器给栈（SP，stackPointer），将stackframe的信息保存到内存中</li></ul><p><strong>编译优化三板斧</strong>：</p><ul><li>函数内联： 将函数调用替换为函数体本身的内容</li><li>常量传播：在编译时计算常量表达式的值并替换</li><li>死代码消除：删除永远不会执行到的代码</li></ul><p><strong>那么给定两个程序A和B，编译器到底允不允许把A编译成B？</strong></p><ul><li>首先要看在syscall调用后两个程序的输出序列是否一致，如果一致则可以编译。</li><li>系统调用是使程序计算结果可见的唯一方法，不改变语义&#x3D;不改变可见结果，即如果两个状态机生成的所有syscall序列是完全一致的，则该优化就是允许的。</li></ul><p><strong>C语言代码中不可优化的部分</strong>：</p><ul><li><p>External function calls外部函数调用（链接时才能确定到底是什么代码）</p><ul><li>未知的代码可能包含系统调用</li><li>因此不可删除，移除循环等，且要保证参数传递完全一致</li></ul></li><li><p>编译器提供的不可优化标注</p></li></ul><h2 id="从硬件视角理解操作系统"><a href="#从硬件视角理解操作系统" class="headerlink" title="从硬件视角理解操作系统"></a>从硬件视角理解操作系统</h2><h3 id="计算机系统的状态机模型"><a href="#计算机系统的状态机模型" class="headerlink" title="计算机系统的状态机模型"></a>计算机系统的状态机模型</h3><ul><li>状态：内存，寄存器的数值</li></ul><p>​寄存器，内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUstate</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>],csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset,mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​还有外部世界的态：</p><ol><li>​设备上的寄存器</li><li>​中断指令Interrput</li><li>​客观存在但计算机系统不能直接访问，进程只能通过syscall访问外部输入</li></ol><ul><li>初始状态：由系统设计者规定（CPU Reset）</li><li>状态迁移：从PC取指令执行</li></ul><h3 id="计算机系统中的固件"><a href="#计算机系统中的固件" class="headerlink" title="计算机系统中的固件"></a>计算机系统中的固件</h3><p>reset是计算机硬件和系统程序员的第一个接口，如果想要在裸机上面进行编程，只需要做一个电路并在适当的内存放上适当的代码，只要cpu在reset状态，就执行相应的某些代码，此时就可以对cpu进行控制。</p><p><strong>什么是固件？</strong></p><ul><li><p>固件就是厂商在出厂时放置到计算机系统里的代码</p><ul><li>之所以称之为固件是因为早期时rom，如果想要更新升级则需要换芯片</li></ul></li><li><p>固件的功能：</p><ul><li>运行程序前的计算机系统配置</li><li>CPU电压，内存时序，接口开关等</li></ul></li><li><p>不严格的说，加载操作系统</p><ul><li>加载存储设备上的引导程序</li></ul></li><li><p>可以成为一个小的操作系统，在CPU reset后初始化硬件，对接操作系统Boot Loader</p></li><li><p>又称为BIOS(basic io system)</p></li><li><p>现在有了UEFI(undefined extensible firmware interface)固件提供更丰富的支持如指纹锁蓝牙键盘等</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法每日一题</title>
      <link href="/2024/11/04/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/04/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Tarjan算法（寻找强连通分量）"><a href="#Tarjan算法（寻找强连通分量）" class="headerlink" title="Tarjan算法（寻找强连通分量）"></a>Tarjan算法（寻找强连通分量）</h2><p>  铺垫：连通图的两种DFS遍历方式， 在tarjan算法中采用方式2来遍历顶点<img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20240911155905523.png" alt="image-20240911155905523"></p><p> 顶点X（i,j）其中</p><p>i：DFS中x点被访问的时间点</p><p>j: x通过可以回溯到的最早时间点</p><p> <img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20240911162218892.png" alt="image-20240911162218892"></p><h3 id="1129-颜色交替的最短路径"><a href="#1129-颜色交替的最短路径" class="headerlink" title="1129 颜色交替的最短路径"></a>1129 颜色交替的最短路径</h3><p>给定一个整数 <code>n</code>，即有向图中的节点数，其中节点标记为 <code>0</code> 到 <code>n - 1</code>。图中的每条边为红色或者蓝色，并且可能存在自环或平行边。</p><p>给定两个数组 <code>redEdges</code> 和 <code>blueEdges</code>，其中：</p><ul><li><code>redEdges[i] = [ai, bi]</code> 表示图中存在一条从节点 <code>ai</code> 到节点 <code>bi</code> 的红色有向边，</li><li><code>blueEdges[j] = [uj, vj]</code> 表示图中存在一条从节点 <code>uj</code> 到节点 <code>vj</code> 的蓝色有向边。</li></ul><p>返回长度为 <code>n</code> 的数组 <code>answer</code>，其中 <code>answer[X]</code> 是从节点 <code>0</code> 到节点 <code>X</code> 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 <code>answer[x] = -1</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []</span><br><span class="line">输出：[0,1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]</span><br><span class="line">输出：[0,1,-1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= redEdges.length, blueEdges.length &lt;= 400</code></li><li><code>redEdges[i].length == blueEdges[j].length == 2</code></li><li><code>0 &lt;= ai, bi, uj, vj &lt; n</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shortestAlternatingPaths</span>(<span class="params">self, n, redEdges, blueEdges</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type redEdges: List[List[int]]</span></span><br><span class="line"><span class="string">        :type blueEdges: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        e=[[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> redEdges:</span><br><span class="line">            e[x].append((y,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> blueEdges:</span><br><span class="line">            e[x].append((y,<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        ans=[-<span class="number">1</span>]*n</span><br><span class="line">        vis=&#123;(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>)&#125;</span><br><span class="line">        q=[(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">        distance=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp=q</span><br><span class="line">            q=[]</span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> ans[x]==-<span class="number">1</span>:</span><br><span class="line">                    ans[x]=distance</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> e[x]:</span><br><span class="line">                    <span class="keyword">if</span> p[<span class="number">1</span>]!=y <span class="keyword">and</span> p <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                        vis.add(p)</span><br><span class="line">                        q.append(p)</span><br><span class="line">            distance+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>解题思路：在路径长度都为一情况下，可以用广度优先遍历一遍便是到各个点的最短路径</em></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="560-和为k的数组个数"><a href="#560-和为k的数组个数" class="headerlink" title="560.和为k的数组个数"></a>560.和为k的数组个数</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 2 * 104</code></p></li><li><p><code>-1000 &lt;= nums[i] &lt;= 1000</code></p></li><li><p><code>-107 &lt;= k &lt;= 107</code></p><p>解题思路：</p><p>用map映射前缀和值和出现的次数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x:nums) &#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238.除自身以外数组的乘积"></a>238.除自身以外数组的乘积</h3><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 <strong>不要使用除法，</strong>且在 <code>O(n)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内</li></ul><p><strong>进阶：</strong>你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; productExceptSelf(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> l=nums.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; L(l,<span class="number">0</span>),R(l,<span class="number">0</span>);</span><br><span class="line">        L[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;l;i++)&#123;</span><br><span class="line">             L[i]=L[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        R[l-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=l-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            R[i]=R[i+<span class="number">1</span>]*nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt;ans(l,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            ans[i]=L[i]*R[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>在C++中，priority_queue是一个容器适配器，它提供了常数时间的最大元素查找。它通常实现为堆。堆是一种数据结构，其中最大（或最小）元素始终位于顶部。priority_queue是一个模板类，定义在头文件中。它有三个模板参数：元素类型、容器类型和比较函数类型（可选）。默认情况下，它使用std::vector作为其底层容器 。</p><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = &#123;q.<span class="built_in">top</span>().first&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">top</span>().second &lt;= i - k) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="53-最大子数列和"><a href="#53-最大子数列和" class="headerlink" title="53.最大子数列和"></a>53.最大子数列和</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong></p><p>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int pre = 0, maxAns = nums[0];</span><br><span class="line">        for (const auto &amp;x: nums) &#123;</span><br><span class="line">            pre = max(pre + x, x);</span><br><span class="line">            maxAns = max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>代码</p><p>测试用例</p><p>测试结果</p><p>测试结果</p><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p> 思路：先对vector进行排序，再根据题意插入</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> L = intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!merged.<span class="built_in">size</span>() || merged.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                merged.<span class="built_in">push_back</span>(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(merged.<span class="built_in">back</span>()[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="234-回文列表"><a href="#234-回文列表" class="headerlink" title="234.回文列表"></a>234.回文列表</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为</p><p>回文链表</p><p>。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/pal1linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/pal2linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><p>尝试用O（1）的空间复杂度进行解答</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == nullptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode* firstHalfEnd = endOfFirstHalf(head);</span><br><span class="line">        ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = secondHalfStart;</span><br><span class="line">        <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != nullptr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd-&gt;next = reverseList(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* <span class="title function_">reverseList</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != nullptr) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* <span class="title function_">endOfFirstHalf</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;     <span class="comment">//快慢指针，慢指针一次移动一步，快指针一次移动两步</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AdvancedMachineLearning结课报告专用</title>
      <link href="/2024/10/23/AdvancedMachineLearning%E7%BB%93%E8%AF%BE%E6%8A%A5%E5%91%8A%E4%B8%93%E7%94%A8/"/>
      <url>/2024/10/23/AdvancedMachineLearning%E7%BB%93%E8%AF%BE%E6%8A%A5%E5%91%8A%E4%B8%93%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="海森矩阵"><a href="#海森矩阵" class="headerlink" title="海森矩阵"></a>海森矩阵</h3><p>是一个多元函数的二阶偏导数构成的方阵，<strong>描述了函数的局部曲率</strong>。在工程实际问题的优化设计中，所列的目标函数往往很复杂，为了使问题简化，常常将目标函数在某点邻域展开成泰勒多项式来逼近原函数，此时函数在某点泰勒展开式的矩阵形式中会涉及到黑塞矩阵。</p><p>对于一个函数</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241024095230966.png" alt="image-20241024095230966" style="zoom: 50%;" /><p>如果f的所有二阶导数都存在，那么f的海森矩阵为：</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241024095330522.png" alt="image-20241024095330522" style="zoom:50%;" /><p>将二元函数的泰勒展开式推广到多元函数，则在一点处的泰勒展开的矩阵形式为：</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241024100815506.png" alt="image-20241024100815506" style="zoom:50%;" /><p>其中<img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241024101048882.png" alt="image-20241024101048882" style="zoom:50%;" />是函数在X0点的梯度，G(X0)就是海森矩阵。</p><p>海森矩阵是由目标函数在x点处的二阶偏导数组成的n*n阶对称矩阵</p><ul><li>如果海森矩阵是一个正定矩阵，则临界点是一个局部极小值</li><li>如果海森矩阵是一个负定矩阵，则临界点是一个局部极大值</li><li>如果是不定矩阵，则临界点处不是极值</li></ul><h3 id="牛顿法优化问题"><a href="#牛顿法优化问题" class="headerlink" title="牛顿法优化问题"></a>牛顿法优化问题</h3><p>牛顿法的基本思想是利用迭代点Xk处的一阶导数(梯度)和二阶导数(Hessen矩阵)对目标函数进行二次函数近似，然后把二次模型的极小点作为新的迭代点，并不断重复这一过程，直至求得满足精度的近似极小值。牛顿法的速度相当快，而且能高度逼近最优值。</p><p>将一个需要求解的损失函数函数f(x)进行泰勒展开到二阶，得到</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241024104750653.png" alt="image-20241024104750653" style="zoom:50%;" /><p>对上式求关于x的导数并令其等于0</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241024104853712.png" alt="image-20241024104853712" style="zoom:50%;" /><p>那么求得极值点的x坐标为<img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241024104946040.png" alt="image-20241024104946040"></p><p>这就是牛顿法的更新公式</p><p>牛顿法的精髓就是二阶收敛，不仅利用了损失函数的一阶偏导数，也用到了损失函数的二阶偏导数，即梯度<strong>变化的趋势</strong>，因此比梯度下降法更快的确定合适的搜索方向，具有二阶收敛速度。</p><h3 id="牛顿法的缺点："><a href="#牛顿法的缺点：" class="headerlink" title="牛顿法的缺点："></a>牛顿法的缺点：</h3><ul><li>计算复杂</li><li>对函数有较为严格的要求，必须具有连续的一阶和二阶偏导数，海森矩阵必须是正定的</li></ul><h2 id="LBFGS优化算法"><a href="#LBFGS优化算法" class="headerlink" title="LBFGS优化算法"></a>LBFGS优化算法</h2><p>在一些经典的优化算法中，比如梯度下降，SGD，Adam等都是在一阶法的基础上进行改进，加快收敛的速率。而牛顿法则是利用二阶法，在收敛速度上远快于一阶，但如果目标函数非凸时，二阶法可能收敛到鞍点。针对二阶法存在的问题提出了BFGS和低存储的LBFGS方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树模型</title>
      <link href="/2024/10/23/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/10/23/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>斯坦福吴恩达2022机器学习</p></blockquote><h2 id="简单的决策树模型"><a href="#简单的决策树模型" class="headerlink" title="简单的决策树模型"></a>简单的决策树模型</h2><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023140523587.png" alt="image-20241023140523587" style="zoom:50%;" /><p>类似于完全二叉树，有根节点和叶节点</p><p>模型建立的两个关键点：</p><ul><li>如何决定分割的特征？</li><li>如何判断叶节点的分类结果好坏？</li></ul><h3 id="纯度测量"><a href="#纯度测量" class="headerlink" title="纯度测量"></a>纯度测量</h3><p>用熵来作为纯度的度量</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023144121398.png" alt="image-20241023144121398" style="zoom: 50%;" /><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023144347508.png" alt="image-20241023144347508" style="zoom:50%;" /><p>当结点中的样本全为猫时，p1&#x3D;1，此时熵的值为0，当样本中全为狗时同理</p><p>当结点中的样本为一半猫一半狗时，p1&#x3D;0.5，此时熵最高为1</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023144944385.png" alt="image-20241023144944385" style="zoom:50%;" /><p>在p&#x3D;0的情形中，log(0)是无法计算的，那么我们需要提前约定0log(0)&#x3D;0，才能正确计算熵</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023145116195.png" alt="image-20241023145116195" style="zoom:33%;" /><h3 id="选择分离的特征"><a href="#选择分离的特征" class="headerlink" title="选择分离的特征"></a>选择分离的特征</h3><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023145853878.png" alt="image-20241023145853878" style="zoom:50%;" /><p>在上图中，每个特征筛选出来的分支都有各自的纯度熵，那么如何根据这些熵来判断哪个特征分类情况最好呢？我们使用每个特征的熵的加权平均来作为评估方式。</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023151127603.png" alt="image-20241023151127603" style="zoom: 50%;" /><p>在耳朵形状这一特征中，五个样本被分到了立耳，五个样本被分到了塌耳，那么则可通过上图公式1来进行加权平均计算出式子2</p><p>根节点的熵为H(5&#x2F;10)&#x3D;1，因为根节点在用特征分类前是十个样本，其中五个样本是猫。</p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023151728440.png" alt="image-20241023151728440"></p><p>最后的评估指标等于根节点的熵减去式子2得到熵的减少，即拆分信息增益，分类特征2和3同理，选择熵的减少量最大的特征。</p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241023190739340.png" alt="image-20241023190739340"></p><h3 id="随机森林算法"><a href="#随机森林算法" class="headerlink" title="随机森林算法"></a>随机森林算法</h3><p>有随机抽样的样本来构建不同的树构成森林</p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241102153124412.png" alt="image-20241102153124412"></p><p>For b&#x3D;1 to B:</p><p>​Use sampling with replacement to create a new training set of size m Train a decision tree on the new dataset</p><h3 id="信息增熵"><a href="#信息增熵" class="headerlink" title="信息增熵"></a>信息增熵</h3><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241104143614684.png" alt="image-20241104143614684" style="zoom:50%;" />信息熵的计算公式</p><p>pk为当前样本集合D中第k类样本所占的比例</p><p>信息熵的值越小则D的纯度越高</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241104144112122.png" alt="image-20241104144112122" style="zoom:50%;" /><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241104144006739.png" alt="image-20241104144006739" style="zoom:50%;" /><p>信息增益越大，则样本在该属性下的纯度提升越大，属性选择更好</p><p>信息增益准则对取值较多的属性有所偏好，仅仅采用增益来选取合适的属性会导致决策树的泛化能力很差</p><h3 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h3><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241104145551003.png" alt="image-20241104145551003" style="zoom:50%;" /><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241104145716126.png" alt="image-20241104145716126" style="zoom:50%;" />为属性a的固有值</p><p>属性a的取值数目越多则固有值越大</p><p>增益率对取值可能较少的属性有所偏好，在C4.5算法中并不是直接取增益率最大的候选划分属性，而是使用了启发式：先从候选属性中选择信息增益高于平均水平的属性集合，再从该集合中选择增益率最高的属性</p><h3 id="CART决策树"><a href="#CART决策树" class="headerlink" title="CART决策树"></a>CART决策树</h3><p>classification and regression tree 分类和回归都可用</p><p>使用基尼指数来选择划分属性</p><p>数据集D的纯度可用基尼值来度量<img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241104151327634.png" alt="image-20241104151327634" style="zoom: 33%;" /></p><p>Gini反应了从数据集D中随机抽取两个样本其类别标记不一样的概率</p><p>属性a的基尼指数定义为<img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241104152734663.png" alt="image-20241104152734663" style="zoom:50%;" /></p><p>选择基尼指数最小的属性</p><h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据集的误差指标与权衡</title>
      <link href="/2024/10/22/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A02022%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/22/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A02022%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程是斯坦福吴恩达2022机器学习</p></blockquote><h3 id="交叉验证集的预测误差指标"><a href="#交叉验证集的预测误差指标" class="headerlink" title="交叉验证集的预测误差指标"></a>交叉验证集的预测误差指标</h3><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241022162017194.png" alt="image-20241022162017194" style="zoom: 50%;" /><ul><li>TP：True Positive预测的分类和实际分类相符且均为正例</li><li>TN：True Negative预测的分类和实际分类相符且均为负例</li><li>FP：False Negative预测的分类和实际分类不符，且预测的是正例</li><li>FN：False Negative预测的分类和实际分类不符，且预测的是负例</li></ul><h3 id="预测精确度的计算："><a href="#预测精确度的计算：" class="headerlink" title="预测精确度的计算："></a>预测精确度的计算：</h3><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241022162508083.png" alt="image-20241022162508083"></p><p>对于精确度我们可以理解为，假设在病人预测中，我们用模型预测的有病的个体中，实际真的患病的人占预测有病的人数的多少，也就是我们模型的预测正例正确的样本数占预测为正例的样本数的多少。</p><h3 id="Recall指标："><a href="#Recall指标：" class="headerlink" title="Recall指标："></a>Recall指标：</h3><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241022162717945.png" alt="image-20241022162717945"></p><p>recall指标可以理解为在所有确实患病的样本中，我们的模型正确预测出了多少样本，即预测正例且正确的样本数占实际为正例的样本数的多少。</p><h3 id="精确度和recall之间的权衡"><a href="#精确度和recall之间的权衡" class="headerlink" title="精确度和recall之间的权衡"></a>精确度和recall之间的权衡</h3><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241022164144857.png" alt="image-20241022164144857"></p><p>假设在病人患病预测中，我们使用罗杰斯蒂回归来预测病人患病的概率，函数返回值大于0.5则预测为正例，若函数返回值小于0.5则预测为负例。但如果患病的话会接受非常痛苦且昂贵的治疗，且患病不治疗的后果并没有那么严重，那么我们可以想要让模型在预测为正例时更加谨慎些，即提高阈值到0.7。</p><p>在提高阈值之后，我们在模型预测为正例的样本中，实际患病的样本数占正例样本更多了，因为我们预测的非常谨慎，那么预测中真的患病的人数也会占更多数，此时我们的精确率会提高。但是相反的，在所有真正患病的样本中，我们预测的患病人数占的比例也少了，recall指标会下降。</p><p>同样，如果假设患病治疗费用和代价很低，但不治疗后果严重，那么我们希望模型在预测患病时没那么严谨，来保证更多的病人被正确预测出疾病，那么就可以降低阈值，此时精确度降低但recall升高。</p><h3 id="F1-score"><a href="#F1-score" class="headerlink" title="F1 score"></a>F1 score</h3><p>如何让模型自动选择合适的权衡？</p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241022170135926.png" alt="image-20241022170135926"></p><p>在这三个算法中，各有优点很难根据精确度和recall评判哪个是最优的算法，这时就需要F1Score帮助</p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241022170421858.png" alt="image-20241022170421858"></p><p>F1Score更高的算法会被选择</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络进阶</title>
      <link href="/2024/10/18/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/10/18/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>课程是b站刘二大人的课，算是速成吧，基础知识不是很多，专注于应用，中间不懂得可以再补</p><h1 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h1><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241018145146213.png" alt="image-20241018145146213"></p><h2 id="Inception-Module"><a href="#Inception-Module" class="headerlink" title="Inception Module"></a>Inception Module</h2><img src="C:\Users\alj\AppData\Roaming\Typora\typora-user-images\image-20241018144916751.png" alt="image-20241018144916751" style="zoom:33%;" /><p>上图的Inception模型是GoogleNet模型中的小块，红色圈中即为Inception</p><p>Concatenate将每一路径得到的张量拼接成一个张量</p><p><strong>在进行Average Pooling池化时，可以进行相应的padding和stride来保证张量的w和h不会改变</strong></p><h3 id="1-1卷积核的作用是什么？"><a href="#1-1卷积核的作用是什么？" class="headerlink" title="1*1卷积核的作用是什么？"></a>1*1卷积核的作用是什么？</h3><p>在1*1卷积核中，我们可以对不同通道的相同位置的像素值进行计算并加和，有此将CxWxH的张量转化为1xWxH的张量，实现降通道操作，具体图示如下：</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241018150809527.png" alt="image-20241018150809527" style="zoom: 25%;" /><h3 id="为什么需要1-1的卷积核？"><a href="#为什么需要1-1的卷积核？" class="headerlink" title="为什么需要1*1的卷积核？"></a>为什么需要1*1的卷积核？</h3><p>可以对图像数据进行降通道的操作，在卷积运算中显著的减少运算量</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241019132722039.png" alt="image-20241019132722039" style="zoom:33%;" /><p>再上图的卷积运算中，我们将192x28x28的数据卷积成32x28x28的数据，需要进行的运算操作数为<br>$$<br>5^2\times28^2\times192\times32&#x3D;120422400<br>$$<br><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241019133516579.png" alt="image-20241019133516579" style="zoom:33%;" /></p><p>如果先对原数据进行1*1的卷积降低通道数，再进行5x5卷积，所需的运算操作数为<br>$$<br>1^2\times28^2\times192\times16+5^2\times28^2\times16\times32&#x3D;12433648<br>$$<br><strong>由此可见运算操作数明显减少</strong></p><h3 id="代码实现及注释"><a href="#代码实现及注释" class="headerlink" title="代码实现及注释"></a>代码实现及注释</h3><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241019150142932.png" alt="image-20241019150142932"></p><p>池化层对应代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.branch_pool = torch.nn.Conv2d(in_channels, <span class="number">24</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">branch_pool = F.avg_pool2d(x, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">branch_pool = <span class="variable language_">self</span>.branch_pool(branch_pool)</span><br></pre></td></tr></table></figure><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241019150259362.png" alt="image-20241019150259362"></p><p>1x1卷积层对应代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.branch1x1 = torch.nn.Conv2d(in_channels, 16, kernel_size=1)</span><br><span class="line"></span><br><span class="line">branch1x1 = self.branch1x1(x)</span><br></pre></td></tr></table></figure><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241019150648224.png" alt="image-20241019150648224"></p><p>5x5卷积层对应代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.branch5x5_1 = torch.nn.Conv2d(in_channels, 16, kernel_size=1)</span><br><span class="line">self.branch5x5_2 = torch.nn.Conv2d(16, 24, kernel_size=5, padding=2)</span><br><span class="line"></span><br><span class="line">branch5x5 = self.branch5x5_1(x)</span><br><span class="line">branch5x5 = self.branch5x5_2(branch5x5)</span><br></pre></td></tr></table></figure><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241019151101886.png" alt="image-20241019151101886"></p><p>3x3卷积层对应代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.branch3x3_1 = torch.nn.Conv2d(in_channels, 16, kernel_size=1)</span><br><span class="line">self.branch3x3_2 = torch.nn.Conv2d(16, 24, kernel_size=3, padding=1)</span><br><span class="line">self.branch3x3_3 = torch.nn.Conv2d(24, 24, kernel_size=3, padding=1)</span><br><span class="line"></span><br><span class="line">branch3x3 = self.branch3x3_1(x)</span><br><span class="line">branch3x3 = self.branch3x3_2(branch3x3)</span><br><span class="line">branch3x3 = self.branch3x3_3(branch3x3)</span><br></pre></td></tr></table></figure><p>最后对每一块得到的卷积张量在通道维度进行合并形成新的张量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outputs = [branch1x1, branch3x3, branch5x5, branch_pool]</span><br><span class="line">return torch.cat(outputs, dim=1)  # 将卷积结果按照通道维度进行拼接</span><br></pre></td></tr></table></figure><p>dim指定在某一维度进行合并张量，包含（batch，通道，宽，高）四个维度</p><p>总体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class InceptionA(torch.nn.Module):</span><br><span class="line">    def __init__(self, in_channels):</span><br><span class="line">        super(InceptionA, self).__init__()</span><br><span class="line">        # 1x1块</span><br><span class="line">        self.branch1x1 = torch.nn.Conv2d(in_channels, 16, kernel_size=1)</span><br><span class="line">        # 5x5块</span><br><span class="line">        self.branch5x5_1 = torch.nn.Conv2d(in_channels, 16, kernel_size=1)</span><br><span class="line">        self.branch5x5_2 = torch.nn.Conv2d(16, 24, kernel_size=5, padding=2)</span><br><span class="line">        # 3x3块</span><br><span class="line">        self.branch3x3_1 = torch.nn.Conv2d(in_channels, 16, kernel_size=1)</span><br><span class="line">        self.branch3x3_2 = torch.nn.Conv2d(16, 24, kernel_size=3, padding=1)</span><br><span class="line">        self.branch3x3_3 = torch.nn.Conv2d(24, 24, kernel_size=3, padding=1)</span><br><span class="line">        # 池化块</span><br><span class="line">        self.branch_pool = torch.nn.Conv2d(in_channels, 24, kernel_size=1)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        branch1x1 = self.branch1x1(x)</span><br><span class="line"></span><br><span class="line">        branch5x5 = self.branch5x5_1(x)</span><br><span class="line">        branch5x5 = self.branch5x5_2(branch5x5)</span><br><span class="line"></span><br><span class="line">        branch3x3 = self.branch3x3_1(x)</span><br><span class="line">        branch3x3 = self.branch3x3_2(branch3x3)</span><br><span class="line">        branch3x3 = self.branch3x3_3(branch3x3)</span><br><span class="line"></span><br><span class="line">        branch_pool = F.avg_pool2d(x, kernel_size=3, stride=1, padding=1)</span><br><span class="line">        branch_pool = self.branch_pool(branch_pool)</span><br><span class="line"></span><br><span class="line">        outputs = [branch1x1, branch3x3, branch5x5, branch_pool]</span><br><span class="line">        return torch.cat(outputs, dim=1)  # 将卷积结果按照通道维度进行拼接</span><br></pre></td></tr></table></figure><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241020154033087.png" alt="image-20241020154033087"></p><h1 id="残差网络Resnet"><a href="#残差网络Resnet" class="headerlink" title="残差网络Resnet"></a>残差网络Resnet</h1><p>随着神经网络层数的不断增加，在反向传播的过程中可能出现梯度爆炸或者梯度消失的情况</p><h3 id="为什么会出现梯度消失或者梯度爆炸？"><a href="#为什么会出现梯度消失或者梯度爆炸？" class="headerlink" title="为什么会出现梯度消失或者梯度爆炸？"></a>为什么会出现梯度消失或者梯度爆炸？</h3><p>现在假设一个模型，其中连接层数为4层，反向传播（Backpropagation）用于计算每一层的权重 WWW 的梯度。这是通过链式法则计算的。假设神经网络的层数从1到4，每一层的输入、权重和激活函数可以定义如下</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241020163910140.png" alt="image-20241020163910140" style="zoom: 50%;" /><p>在计算离输入层较近的层的梯度时，会发现梯度的计算来源于上层的计算总和</p><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241020184804511.png" alt="image-20241020184804511"></p><p>链式法则是一个连乘的操作，在多次乘积操作后，最后一层的梯度可能趋近于零，也就是梯度消失，但若偏导数值大则会出现梯度爆炸的情况。</p><h3 id="梯度消失-梯度爆炸的解决方法"><a href="#梯度消失-梯度爆炸的解决方法" class="headerlink" title="梯度消失&#x2F;梯度爆炸的解决方法"></a>梯度消失&#x2F;梯度爆炸的解决方法</h3><ol><li><p>梯度剪切：针对于梯度爆炸的情况，将梯度限制在一个限定的阈值内，如果更新梯度时梯度超过了阈值则将梯度改为阈值的边界，防止梯度过大的情况出现。</p></li><li><p>权重正则化：通过对权重做正则化来避免过拟合的情况出现，在梯度爆炸是权重的值可能会非常高，用正则化项来限制权重的大小，防止梯度爆炸的情况发生。</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241021141852661.png" alt="image-20241021141852661" style="zoom:50%;" /><p>其中α为正则化项的系数</p></li><li><p>用Relu代替sigmoid作为激活函数：使用sigmoid函数作为激活函数时梯度值小于等于0.25，在连乘操作后显然会出现梯度消失或梯度爆炸的问题，但如果我们使用Relu函数作为激活函数，在对激活函数求导时，大于0的部分导数是恒等于1的，连乘不会出现梯度消失问题。</p></li><li><p>Batchnorm：通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。</p></li><li><p>残差网络</p></li></ol><h3 id="残差网络如何解决梯度消失问题"><a href="#残差网络如何解决梯度消失问题" class="headerlink" title="残差网络如何解决梯度消失问题?"></a>残差网络如何解决梯度消失问题?</h3><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241021145340356.png" alt="image-20241021145340356" style="zoom:50%;" /><p>在原始的堆叠模型中，我们将需要的底层映射结果设为H(x)，则H(x)&#x3D;F(x)</p><p>但是在残差学习块中，我们假设需要的底层映射结果仍为H(x),在堆叠的非线性层我们让其训练另一个映射：F(x)&#x3D;H(x)-x，则原始的底层映射结果改变为H(x)&#x3D;F(x)+x,那么在上文的反向传播梯度计算中，公式可变为：</p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241021151441848.png" alt="image-20241021151441848" style="zoom:50%;" /><p>由此可见，连乘的因式有大于一的项，能够有效避免梯度消失问题。</p><p>如果还没有理解可以参考链接：<a href="http://www.atait.se.ritsumei.ac.jp/AIArc/WangZC/ResNet.pdf">http://www.atait.se.ritsumei.ac.jp/AIArc/WangZC/ResNet.pdf</a></p><h3 id="模型实现及代码复现"><a href="#模型实现及代码复现" class="headerlink" title="模型实现及代码复现"></a>模型实现及代码复现</h3><p><img src="https://simonpic-1330571413.cos.ap-nanjing.myqcloud.com/picblog/image-20241021160358150.png" alt="image-20241021160358150"></p><p>与原始的堆叠模型不同的是，在堆叠块中添加跳连接</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResidualBlock</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, channels</span>):</span><br><span class="line">        <span class="built_in">super</span>(ResidualBlock, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.channels = channels</span><br><span class="line">        <span class="variable language_">self</span>.conv1 = torch.nn.Conv2d(channels, channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)  <span class="comment"># padding来保证维度不会改变</span></span><br><span class="line">        <span class="variable language_">self</span>.conv2 = torch.nn.Conv2d(channels, channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = F.relu(<span class="variable language_">self</span>.conv1(x))</span><br><span class="line">        y = <span class="variable language_">self</span>.conv2(y)</span><br><span class="line">        <span class="keyword">return</span> F.relu(x + y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ResNet, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.conv1 = torch.nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = torch.nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.mp = torch.nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        <span class="variable language_">self</span>.rblock1 = ResidualBlock(<span class="number">16</span>)</span><br><span class="line">        <span class="variable language_">self</span>.rblock2 = ResidualBlock(<span class="number">32</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc = torch.nn.Linear(<span class="number">512</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        in_size = x.size(<span class="number">0</span>)</span><br><span class="line">        x = <span class="variable language_">self</span>.mp(F.relu(<span class="variable language_">self</span>.conv1))</span><br><span class="line">        x = <span class="variable language_">self</span>.rblock1(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.mp(F.relu((<span class="variable language_">self</span>.conv2)))</span><br><span class="line">        x = <span class="variable language_">self</span>.rblock2(x)</span><br><span class="line">        x = x.view(in_size, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.fc(x)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/10/17/hello-world/"/>
      <url>/2024/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
